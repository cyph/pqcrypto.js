/** 
 * \file rbc_lrpc.cpp
 * \brief Implementation of lrpc.h
 */

#include "lrpc.h"
#include "rbc_elt.h"
#include "rbc_qre.h"
#include "rbc_vspace.h"
#include "rbc_vec.h"

/**
 * @fn         unsigned int rbc_lrpc_RSR(rbc_vspace E, const uint32_t E_expected_dim, const rbc_vspace F, const uint32_t F_dim, const rbc_qre ec, const uint32_t ec_size)
 *
 * @brief      This function implements the rank_support_recover using
 *             the general decoding algorithm of the LRPC codes.
 *
 *             As explained in the supporting documentation, the provided
 *             algorithm works as follows:
 *   1. Compute the vector space <b>S</b> generated by the coordinates of
 *      <b>ec</b> ;
 *   2. Retrieve the support <b>E</b> by computing the intersection of the
 *      spaces <b>Si</b> = <b>F[i]^(-1)</b> * <b>S</b>.
 *
 * @param[out] E               Support of <b>r1</b> and <b>r2</b>
 * @param[in]  E_expected_dim  Expected dimension of the support <b>E</b>
 * @param[in]  F               Support of the vectors <b>x</b> and <b>y</b>
 * @param[in]  F_dim           Dimension of the support <b>F</b>
 * @param[in]  ec              Vector <b>ec</b> = <b>x</b>.<b>r2</b> -
 *                             <b>y</b>.<b>r1</b> + <b>er</b>
 * @param[in]  ec_size         Size of the vector <b>ec</b>
 * @param[in]  E_dim           Dimension of the support <b>E</b>
 *
 * @return     { description_of_the_return_value }
 */
unsigned int rbc_lrpc_RSR(rbc_vspace E, const uint32_t E_expected_dim, const rbc_vspace F, const uint32_t F_dim, const rbc_qre ec, const uint32_t ec_size) {
  /*
   * Step 1: Compute the vector space S 
   */ 

  // Compute the vector space S from the coordinates of ec (line 1)
  rbc_vspace S;
  uint32_t S_dim;
  uint32_t E_dim;
  rbc_vspace Si[F_dim];
  rbc_elt Fi_inv;

  rbc_vspace_init(&S, ec_size);
  rbc_vspace_set(S, ec->v, ec_size);
  S_dim = rbc_vec_gauss(S, ec_size);

  /*
   * Step 2: Recover the vector space E 
   */ 
  //Code supposes that PARAM_N > PARAM_R * PARAM_D

  // Compute the spaces Si = F[i]^(-1) * S (line 10)
  for(size_t i = 0 ; i < F_dim ; ++i) {
    rbc_vspace_init(&(Si[i]), S_dim);
    rbc_elt_inv(Fi_inv, F[i]);
    rbc_vec_scalar_mul(Si[i], S, Fi_inv, S_dim);
  }

  //Intersect every Si,i+1
  //This supposes d >= 4
  E_dim = rbc_vspace_intersection(E, Si[0], Si[1], S_dim, S_dim);

  for(size_t i = 0 ; i < F_dim ; i++) {
    if(E_dim == E_expected_dim) break;
    E_dim = rbc_vspace_intersection(E, E, Si[i], E_dim, S_dim);
  }

  rbc_vec_echelonize(E, E_dim);

  rbc_vspace_clear(S);
  for(size_t i = 0 ; i < F_dim ; ++i) {
    rbc_vspace_clear(Si[i]);
  }

  #ifdef VERBOSE
    printf("\n\n# Rank Support Recover - Begin #");
    printf("\n\nS: "); rbc_vec_print(S, E_expected_dim * F_dim);
    for(size_t i = 0 ; i < F_dim ; ++i) {
      printf("\n\nS%i: ", i); rbc_vec_print(Si[i], E_expected_dim * F_dim);
    }
    printf("\n\nE: "); rbc_vec_print(E, E_dim);
    printf("\n\n# Rank Support Recover - End #");
  #endif

  return E_dim;
}

/**
 * @fn         unsigned int rbc_lrpc_RSR_constant_time(rbc_vspace E, const uint32_t E_expected_dim, const rbc_vspace F, const uint32_t F_dim, const rbc_qre ec, const uint32_t ec_size)
 *
 * @brief      This function implements the rank_support_recover using
 *             the general decoding algorithm of the LRPC codes, with
 *             the constant time Gauss implementation.
 *
 *             As explained in the supporting documentation, the provided
 *             algorithm works as follows:
 *   1. Compute the vector space <b>S</b> generated by the coordinates of
 *      <b>ec</b> ;
 *   2. Retrieve the support <b>E</b> by computing the intersection of the
 *      spaces <b>Si</b> = <b>F[i]^(-1)</b> * <b>S</b>.
 *
 * @param[out] E               Support of <b>r1</b> and <b>r2</b>
 * @param[in]  E_expected_dim  Expected dimension of the support <b>E</b>
 * @param[in]  F               Support of the vectors <b>x</b> and <b>y</b>
 * @param[in]  F_dim           Dimension of the support <b>F</b>
 * @param[in]  ec              Vector <b>ec</b> = <b>x</b>.<b>r2</b> -
 *                             <b>y</b>.<b>r1</b> + <b>er</b>
 * @param[in]  ec_size         Size of the vector <b>ec</b>
 * @param[in]  E_dim           Dimension of the support <b>E</b>
 *
 * @return     { description_of_the_return_value }
 */
#pragma GCC push_options
#pragma GCC optimize ("O0")
unsigned int rbc_lrpc_RSR_constant_time(rbc_vspace E, const uint32_t E_expected_dim, const rbc_vspace F, const uint32_t F_dim, const rbc_qre ec, const uint32_t ec_size) {


  /*
   * Step 1: Compute the vector space S 
   */ 

  // Compute the vector space S from the coordinates of ec (line 1)
  rbc_vspace S;
  rbc_vspace Si[F_dim];
  rbc_elt Fi_inv;
  uint32_t E_dim;

  rbc_vspace_init(&S, ec_size);
  rbc_vspace_set(S, ec->v, ec_size);
  rbc_vec_gauss_constant_time(S, ec_size, NULL, 0);

  /*
   * Step 2: Recover the vector space E 
   */ 
  //Code supposes that PARAM_N > PARAM_R * PARAM_D

  // Compute the spaces Si = F[i]^(-1) * S (line 10)
  for(size_t i = 0 ; i < F_dim ; ++i) {
    rbc_vspace_init(&(Si[i]), E_expected_dim * F_dim);
    rbc_elt_inv(Fi_inv, F[i]);
    rbc_vec_scalar_mul(Si[i], S, Fi_inv, E_expected_dim * F_dim);
  }

  //Intersect every Si
  rbc_vspace_intersection_constant_time(E, Si[0], Si[1], E_expected_dim * F_dim, E_expected_dim * F_dim);

  for(size_t i = 2 ; i < F_dim ; i++) {
    rbc_vspace_intersection_constant_time(E, E, Si[i], E_expected_dim * F_dim, E_expected_dim * F_dim);
  }

  E_dim = rbc_vec_gauss_constant_time(E, E_expected_dim * F_dim, NULL, 0);

  rbc_vspace_clear(S);
  for(size_t i = 0 ; i < F_dim ; ++i) {
    rbc_vspace_clear(Si[i]);
  }

  #ifdef VERBOSE
    printf("\n\n# Rank Support Recover - Begin #");
    printf("\n\nS: "); rbc_vec_print(S, E_expected_dim * F_dim);
    for(size_t i = 0 ; i < F_dim ; ++i) {
      printf("\n\nS%i: ", i); rbc_vec_print(Si[i], E_expected_dim * F_dim);
    }
    printf("\n\nE: "); rbc_vec_print(E, E_dim);
    printf("\n\n# Rank Support Recover - End #");
  #endif


  return E_dim;
}
#pragma GCC pop_options
